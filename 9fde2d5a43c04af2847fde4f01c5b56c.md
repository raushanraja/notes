id: 9fde2d5a43c04af2847fde4f01c5b56c
parent_id: 
item_type: 1
item_id: 9fe1f24e60e94a62b174424b2a365c88
item_updated_time: 1705168123065
title_diff: "[{\"diffs\":[[1,\"String\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":6}]"
body_diff: "[{\"diffs\":[[1,\"There are two types of strings in Rust: `String` and `&str`.\\\n-  &str :\\\n\\t- `&str` is a **slice** `(&[u8])` that always points to a valid UTF-8 sequence,\\\n\\t- Itcan be used to view into a String, just like `&[T]` is a view into `Vec<T>`.\\\n\\\n\\\n- String \\\n\\t- A String is stored as a vector of bytes (Vec<u8>)\\\n    - It is guaranteed to always be a valid UTF-8 sequence.  \\\n\\t- String is heap allocated, growable and not null terminated.\\\n\\\n- Ways to Create &str and String\\\n```rust\\\n// &str\\\n\\t// 1. Create a &str just by creating a variable\\\n\\tlet keyword = \\\"literal\\\";\\\n\\\n\\t// 2.Create a &str by getting a silce out of String\\\n\\tlet alice = String::from(\\\"I like turtles\\\"); // This creates a String\\\n\\tlet alice_says  = alice[..]  // This creates a &str (a slice of String)\\\n\\\n\\\n// String\\\n\\t// 1.\\\n\\tlet alice = String::from(\\\"I like turtles\\\");\\\n\\t\\\n\\t// 2.\\\n\\tlet alice = \\\"I like turtles\\\".to_string();\\\n\\\n\\t// 3.\\\n\\t// Empty and growable String\\\n\\tlet alice = String::new();\\\n\\\n\\t\\t// adding a chat at a time\\\n\\t\\talice.push('I');\\\n\\t\\talice.push(' ');\\\n\\t\\talice.push('L');\\\n\\\n\\t\\t// adding str\\\n\\t\\talice.push_str(\\\"ike turtles\\\");\\\n```\\\n\\\n\\\n### String\\\n##### Collection of `chars` to `String`\\\n- use `.iter().collect()::<String>();\\\n##### Collection of `String` or `&str` to String\\\n- use `.concat()`\\\n##### Join using seperator between string\\\n- use `.join()`\\\n- Examples:\\\n```rust\\\n\\t// chat to string\\\n\\t\\tlet chars = vec!['a', 'b', 'c'];\\\n\\t\\tlet string = chars.iter().collect::<String>();\\\n\\t\\tprintln!(\\\"vec: {:?}, string: {}\\\", chars, string);\\\n\\\n\\t\\tlet chars_array = ['a', 'b', 'c'];\\\n\\t\\tlet string = chars.iter().collect::<String>();\\\n\\t\\tprintln!(\\\"vec: {:?}, string: {}\\\", chars, string);\\\n\\\n\\t\\tlet slice_chars = &chars[..];\\\n\\t\\tlet string = chars.iter().collect::<String>();\\\n\\t\\tprintln!(\\\"vec: {:?}, string: {}\\\", chars, string);\\\n\\\n\\t// joining collection of string/&str to String\\\n\\t\\tlet names = [\\\"firstName\\\", \\\"lastName\\\"];\\\n\\t\\tlet name = names.concat(); // Output: \\\"firstNamelastName\\\"\\\n\\t\\t\\t\\t\\t// or\\\n\\t\\tlet name = name.join(\\\".\\\"); // Output: \\\"firstName.lastName\\\"\\\n\\\n\\t// Making Capitalcase\\\n    names.split(\\\" \\\")\\\n        .map(|x| x[0..1].to_uppercase())\\\n        .collect::<Vec<String>>()\\\n        .join(\\\".\\\") ; // Output: F.N\\\n\\\n``` \\\n\\\n#### Commonly used methods\\\n|||\\\n|-|-|\\\n|String|&str||\\\n||chars|\\\n|len|len|\\\n||split|\\\n\\\n\\\n##### chars\\\n- next()\\\n- last()\\\n- nth(index)\\\n- Example\\\n\\t```rust\\\n\\t\\\n\\t// Matches if first and last character of  both &str is same\\\n\\tfn feast_two(beast: &str, dish: &str) -> bool {\\\n    \\tbeast.chars().next() == dish.chars().next() && \\\n\\t\\tbeast.chars().last() == dish.chars().last()\\\n\\t}\\\n\\t```\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":2481}]"
metadata_diff: {"new":{"id":"9fe1f24e60e94a62b174424b2a365c88","parent_id":"6260d9c9d06f4a5bb6de5be6751f3394","latitude":"28.61393910","longitude":"77.20902120","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_data":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-01-13T17:55:27.498Z
created_time: 2024-01-13T17:55:27.498Z
type_: 13