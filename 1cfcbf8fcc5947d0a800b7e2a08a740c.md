id: 1cfcbf8fcc5947d0a800b7e2a08a740c
parent_id: 
item_type: 1
item_id: 63b28440f5424f398fa1343d2ed693a1
item_updated_time: 1699369385136
title_diff: "[{\"diffs\":[[1,\"Organization: Function, Struct, Module\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":38}]"
body_diff: "[{\"diffs\":[[1,\"\\\n\\\n\\\n## Organizing for Reuse:\\\n\\\n- Encapsulating`behaviour` with `function`\\\n- Encapsulation `data` with `struct`\\\n- Exporting and Importig `moudles`\\\n\\\n* * *\\\n\\\n## Function:\\\n\\\n- Function encapsulates behaviour\\\n    \\\n- It is code construct that call be called from different places\\\n    \\\n- It takes parameter and retruns value to transfer data back and forth.\\\n    \\\n- In Rust, functions are associated with struct\\\n    \\\n- A type may have two types of function:\\\n    \\\n    - `Associated function`: Function associated with Type instead to a particular instance\\\n        - `::` syntax is used to access the function.\\\n    - `Method` Functions associated with a particular instance of a type.\\\n        - `.` (dot) is used to access the function\\\n- Syntax:\\\n    \\\n    ```rust\\\n        fn functon_name() -> return_type {\\\n            // function body\\\n        }\\\n    \\\n        //Example:\\\n        fn four() -> i32 {\\\n            4\\\n        }\\\n        \\\n    ```\\\n    \\\n- Parameterizing Functoins:\\\n    \\\n    - Parameters are variables that are available when function executes\\\n    - There variable value are filled with values from the outside.\\\n    - Few parameter types:\\\n    \\\n    | Parameter Type | Explaination |\\\n    | --- | --- |\\\n    | `fn f(a: &str)` | `&`\\\\- prefix provides an immutable reference to a function. (Borrow). |\\\n    | `fn f(mut a: String)` | `mut` provides a varialbe that is mutable (Borrow). |\\\n    | `no prefix` | Simple transfer of ownership into the function. eg: `fn(a:i32)` |\\\n    | `impl` | Prefix Allows structs/enums that implement a trait dynamically. eg: `fn(a: impl str::io::Write)` |\\\n    | T `generic types` | T or other `generic types` are represented through letters. eg: `fn f<T>(a: T)` |\\\n    \\\n\\\n* * *\\\n\\\n## Struct\\\n\\\n- `struct` enacpsulates the data.\\\n- It is use to store complex type under a single variable to ensure unformity and reusablity.\\\n- When allocating a struct, the values for the members are required to be provided.\\\n- Syntax:\\\n    \\\n    ```rust\\\n        struct StructName { \\t\\t\\t\\t// convention: struct name is CamelCase\\\n            variable_one: type,\\\n            variable_two: type\\\n        }\\\n    \\\n        // Example:\\\n        // Defining a struct\\\n        struct Door {\\\n            width: u32,\\\n            height: u32,\\\n            is_open: bool\\\n        }\\\n    \\\n        // Using the struct\\\n        fn main(){\\\n            let living_room_door = Door({width:100, height:200, is_open: false});\\t\\\n            println!(\\\"Is room open {}\\\", living_room_door.is_open);\\\n        }\\\n        \\\n    ```\\\n    \\\n- Modifier with struct:\\\n    - modifiers with structs are use to restrict the access to struct and its members\\\n    - Typically `pub` is the modifier used in Rust.\\\n    - Example:\\\n        \\\n        ```rust\\\n            pub struct Door{ \\t\\t\\t\\t// Makes struct accessible from outside\\\n                width: u32,\\t\\t\\t\\t\\t// ❌ Not accessible from different module\\\n                height: u32,\\t\\t\\t\\t// ❌ Not accessible from different module\\\n                pub is_bool: bool \\t\\t\\t\\t// ✔️ Accessible from different module\\\n            }\\\n            \\\n        ```\\\n        \\\n- Association `function` with `struct`\\\n    - `impl` block provides function implementation for a specified struct (or even for enums).\\\n    - A `impl` block can have multiple function.\\\n    - It is also fine to have several `impl` blocks too.\\\n    - `impl` is defined with the same name as struct.\\\n    - Two types of functions in `impl` block:\\\n        - General function that are bound to Struct and do not have instance data available to it.\\\n            - Accessed by `::` operator\\\n        - Instance bound function that have the instance data and can mutate the data.\\\n            - Accessed by `.` operator\\\n    - Example:\\\n        \\\n        ```rust\\\n            // Defining a struct\\t\\\n            struct Door {\\\n                width: u32,\\\n                height: u32,\\\n                is_open: bool\\\n            }\\\n        \\\n            // Associating functions with a struct\\\n            // impl has same name as struct\\\n            impl Door {\\\n                \\\n                // General method\\\n                // Don't have insatnce data availble to this method\\\n                // And return type is Self, which refers to current type\\\n                pub fn new(width: u32, height: u32, is_open: bool) -> Self {\\\n                    Door{\\t\\t\\t\\t\\t\\t     \\\n                        width,   // shorthand for width:width\\\n                        height,\\\n                        is_book\\\n                    }\\\n                }\\t\\\n                \\\n                // Instance bound method\\\n                // first parameter is self and it can be mutable if defined with &mut \\\n                pub fn open(&mut self) {\\\n                    self.is_open = true;\\\n                } \\\n                \\\n                pub fn close(&mut self){\\\n                    self.is_open = false;\\\n                }\\\n            }\\\n            \\\n        ```\\\n        \\\n\\\n## Modules: Export and Import\\\n\\\n- Module is used to abstract code component for easy reuse.\\\n- These modules can be used from anywhere by importting it.\\\n- Basic Steps:\\\n    - Create a functoin/struct/enum etc that needs to be converted into a module\\\n    - Use `mod` keyword to declare it as a module\\\n    - Use `use` keyword to get a specific thing or whole module into other file.\\\n- Aliasing types and modules\\\n    - using `as ;` contruct : `use Door as Gate;`\\\n    - using `type` keyword : `type TwoNumbers = (u64, u64);`\\\n    - using `pub type` keyword: `pub type EmptyResult = Result<(), MyError>;*emphasized text*`\\\n- Different ways of creating a module:\\\n\\\n1.  Creating modules in same file using `mod` keyword\\\n    - `mod` keyword isused with a module name, in the same file\\\n    - `pub` keyword is used with fucntion/enun/struct which is to be exported\\\n    - Example:\\\n        \\\n        ```rust\\\n            // Example of creating a module\\\n            // Both module and function that is using the module are in same file.\\\n        \\\n            mod PhysicalAccessControl {\\t\\t// Creating a module\\\n                pub struct Door {\\\n                    pub width: u32,\\\n                    pub heigh: u32,\\\n                    pub is_open: bool\\\n                }\\\n                \\\n                impl Door{\\\n                    pub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n                        Door{\\\n                            width,\\\n                            height,\\\n                            is_open,\\\n                        }\\\n                    }\\\n                }\\\n            }\\t\\\n        \\\n        \\\n            // Using PhysicalAccessControl module create above in different scope\\\n            fn main(){\\t\\t\\t\\\n                let my_door = PhysicalAccessControl::Door::new(100, 200, false);\\\n            }\\\n            \\\n        ```\\\n        \\\n2.  Creating module in a dedicated file\\\n    \\\n    - Create a dedicated file with required code.\\\n    - The filename is used as module name, the module name is not defined in the module code.\\\n    - The file which usages it need to declare the module in a `mod` statement with filename.\\\n    - Afterward, a `use` statement enables the inclusion of module's code in current file.\\\n    - Example:\\\n    \\\n    ```rust\\\n       // PhysicalAccessControl.rs   <---- A dedicated file for the module \\t\\t\\t\\t\\\n        pub struct Door {  \\t    //   <---- We are not using `mod` statement with module name here\\\n            pub width: u32,\\\n            pub heigh: u32,\\\n            pub is_open: bool\\\n        }\\\n    \\\n        impl Door{\\\n            pub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n                Door {\\\n                    width,\\\n                    height,\\\n                    is_open,\\\n                }\\\n            }\\\n        }\\\n    \\\n    \\\n        // main.rs       \\t\\t       \\t   <----Different file which usages the module\\\n        mod PhysicalAccessControl;  //         <---- using `mod` statement to declare the module\\\n        use PhysicalAccessControl::Door; //    <---- using `use` statmenet to include `Door` struct\\\n    \\\n        fn main(){\\\n            let my_door = Door::new(100, 300, false);\\t\\\n        }\\\n            \\\n    ```\\\n    \\\n3.  Modules when they are in different directories (Sub-modules)\\\n    \\\n    - When modules are further divided into multiple parts and different directories.\\\n    - Each directory needs to contain a file called `mod.rs` to create it a submodule.\\\n    - Each new file has to be declared in `mod.rs` with `mod submodule;` keyword for `submodule.rs` file.\\\n    - `use submodule` is used in the file where it is used.\\\n    - The root directory contains a `lib.rs` and all top level submodules are declared in lib.rs with mod keyword.\\\n    - Example:\\\n    \\\n    ```rust\\\n       // PhysicalAccessControl.rs   <---- A dedicated file for the module \\t\\t\\t\\t\\\n        pub struct Door {  \\t    //   <---- We are not using `mod` statement with module name here\\\n            pub width: u32,\\\n            pub heigh: u32,\\\n            pub is_open: bool\\\n        }\\\n    \\\n        impl Door{\\\n            pub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n                Door {\\\n                    width,\\\n                    height,\\\n                    is_open,\\\n                }\\\n            }\\\n        }\\\n    \\\n        struct Window {    //   <---- struct private to moudle, as not using `pub` keyword\\\n            pub width: u32,\\\n            pub heigh: u32,\\\n            pub is_open: bool\\\n        }\\\n    \\\n    \\\n    \\\n        // main.rs   <----Different file which usages the module defined above\\\n        mod PhysicalAccessControl;  //                 \\\n        use PhysicalAccessControl::Door as Gate; //    <---- Aliasing import\\\n        use PhysicalAccessControl::Window; //          <---- Fails because struct is private to module\\\n        fn main(){\\\n            let my_door = Gate::new(100, 300, false);\\t\\\n        }\\\n        \\\n    ```\\\n    \\\n\\\n### Enum\\\n\\\n- User defined data types with optionally data associated with it.\\\n    \\\n- It represents that data is one fo serveral possible variants (which distinguishes it from struct)\\\n    \\\n- Useful in handing input (by giving a collection of types a name)\\\n    \\\n- [https://web.mit.edu/rust-lang\\\\_v1.25/arch/amd64\\\\_ubuntu1404/share/doc/rust/html/book/first-edition/enums.html](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/enums.html) last stopped here\\\n    \\\n- Syntax:\\\n    \\\n    ```rust\\\n        enum name\\\n        {\\\n            variable1,\\\n            variable2,\\\n            variable3,\\\n        }\\\n    \\\n    ```\\\n    \\\n\\\n#### Operations with/on enums:\\\n\\\n##### Matching enum vairants:\\\n\\\n- `match` keywors can be used to match do pattern matching on enums.\\\n- Exampld:\\\n\\\n```rust\\\nenum Example {\\\n    This,\\\n    That\\\n}\\\n\\\n\\\nfn matcher(x: Example){\\\n    match x {\\\n        Example::This => println!(\\\"We got This\\\"),\\\n        Example::That => println!(\\\"we got That\\\"),\\\n    }\\\n}\\\n\\\nmatcher(Example::This);\\\nmathcer(Exmaple::That);\\\n\\\n// Output:\\\nWe got This\\\nwe got That\\\n```\\\n\\\n- Adding To and From string for enum\\\n\\\n```rust\\\n#[derive(Debug, PartialEq)]\\\nenum Methods {\\\n    Register,\\\n}\\\n\\\n\\\nimpl FromStr for Methods {\\\n    type Err = ();\\\n\\\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\\\n        match s {\\\n            \\\"Register\\\" => Ok(Self::Register),\\\n            _ => Err(()),\\\n        }\\\n    }\\\n}\\\n\\\nimpl fmt::Display for Methods {\\\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\\\n        fmt::Debug::fmt(&self, f)\\\n    }\\\n}\\\n```\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":11271}]"
metadata_diff: {"new":{"id":"63b28440f5424f398fa1343d2ed693a1","parent_id":"6260d9c9d06f4a5bb6de5be6751f3394","latitude":"19.07598370","longitude":"72.87765590","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":1674738582925,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-11-07T15:12:18.535Z
created_time: 2023-11-07T15:12:18.535Z
type_: 13