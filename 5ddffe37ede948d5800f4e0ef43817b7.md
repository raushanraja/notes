id: 5ddffe37ede948d5800f4e0ef43817b7
parent_id: 
item_type: 1
item_id: cd7dc553aaee4a198e9fd8965dbdb67d
item_updated_time: 1696156578990
title_diff: "[{\"diffs\":[[1,\"Nom: Parser\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":11}]"
body_diff: "[{\"diffs\":[[1,\"#### Nrm\\\n- Used to build parsers and helps combine them using combinators.\\\n- The nor parser takean and input and returns a result.\\\n    - In result, it result \\\n        - `Ok` indicating gthe parser succssfully found what it was looking for.\\\n        - `Err` indicating it could not found what it was looking for.\\\n- When it's okay `Ok`, it restuls a tuple. \\\n    - First field: Contains everything that parser did not processed.\\\n    - Second field everything parser processed. \\\n- When it fails `Err`, it resutls multiple errors (More on this lated)\\\n\\\n- So the parsed process looks something like this, as given in figure and same this is represented by `IResult<I,O>` in code :\\\n```md\\\n                                   ┌─► Ok(\\\n                                   │      what the parser didn't touch, # This is the first field of tuple\\\n                                   │      what matched the regex        # The Second field of the tuple\\\n                                   │   )\\\n             ┌─────────┐           │\\\n my input───►│my parser├──►either──┤\\\n             └─────────┘           └─► Err(...)\\\n```\\\n\\\n\\\n##### IResult<I,O>\\\n- Nom usages IResult<I,O> type to represent the model given in figure.\\\n- The `Ok` variant takes two types `I` (=Input) and `O` (=Output).\\\n- The `Err` variant stores an error \\\n- The type is import from as `use nom::IResult`\\\n\\\n\\\n##### Tags\\\n- A collection of bytes in nom is call a tag. Example: \\\"abc\\\" is a tag and created as tag(\\\"abc\\\")\\\n- Tags are so common that there exists function called `tag` & `tag_no_case` in nom.\\\n- It helps in parsing  when matching a string\\\n- Warning: There are multiple definition of tag in nom, use the correct one.\\\n- `pub use nom::bytes::complete::tag;`\\\n\\\n\\\n##### Characters\\\n- Tags are useful but they are restrictive.\\\n- Characters are pre-written parsers in nom, which allows to parse any group of characters.\\\n- This differs from tag, as Characters allows to accept any group of characters, \\\nrather than just accepting characters in defined sequence.\\\n- Selection of Characters Parsers:\\\n\\\n| Function       | Character Symbol | Description |\\\n|----------------|-|-------------------------------------------------------------------------------------------------------|\\\n| `alpha0`       | `[a-zA-Z]`    | Recognizes zero or more lowercase and uppercase alphabetic characters: /[a-zA-Z]/. `alpha1` does the same but returns at least one character.|\\\n| `alphanumeric0`| `[0-9a-zA-Z]` | Recognizes zero or more numerical and alphabetic characters: /[0-9a-zA-Z]/. `alphanumeric1` does the same but returns at least one character.|\\\n| `digit0`       | `[0-9]`       | Recognizes zero or more numerical characters: /[0-9]/. `digit1` does the same but returns at least one character.|\\\n| `multispace0`  |               | Recognizes zero or more spaces, tabs, carriage returns, and line feeds. `multispace1` does the same but returns at least one character.|\\\n| `space0`       |               | Recognizes zero or more spaces and tabs. `space1` does the same but returns at least one character.|\\\n| `line_ending`  | `\\\\\n & \\\\\r\\\\\n`   | Recognizes an end of line (both \\\\\n and \\\\\r\\\\\n).|\\\n| `newline`      | `\\\\\n`          | Matches a newline character \\\\\n.|\\\n| `tab`          | `\\\\t`          | Matches a tab character \\\\t.|\\\n\\\n\\\n\\\n#####  Alternatives and Composition\\\n- Alternatives are used to choose between multiple parser untill one is succssfull.\\\n- Composition is used to chian multiple parser and evaluate all of them.\\\n\\\n- `Alternative`:\\\n    - Nom provides`use nod::branch::alt;` which gives the ability to choose between parsers.\\\n    - The `alt()` takes tuple (of parsers) as input \\\n        - and executes each parser untill it finds one the does not error (or parse succssfully).\\\n\\\n- `Compoisition`:\\\n    - Nom provides another built-in combinator `use nom::sequence::tuple;`, which gives the ability to run all the parsed and get result.\\\n    - The tuple() combinator takes a tuple of parsers, \\\n        - and either returns Ok with a \\\n            - First field with all the not processed string \\\n            - Second, tuple of all of their successful parses as tuple\\\n                - The length of this tuple depends of number of parser used in `tuple()`\\\n                - The structure could also chage based on the praser used, I.E, when used a tag, it will in turn return a tuple \\\n        - or it returns the Err of the first failed parser.\\\n\\\n- Other combinators:\\\n    - `delimited` : Discard - Parse - Discard\\\n    - `preceded` : Discard - Parse\\\n    - `terminated` : Parse - Discard\\\n    - `pair` : Parse - Parse\\\n    - `seperated_pair` : Parse - Seperator (Discard) - Parse\\\n\\\n\\\n### References:\\\n- https://docs.rs/nom/latest/nom/character/complete/index.html\\\n- https://docs.rs/nom/latest/nom/sequence/index.html#functions\\\n\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":4732}]"
metadata_diff: {"new":{"id":"cd7dc553aaee4a198e9fd8965dbdb67d","parent_id":"6260d9c9d06f4a5bb6de5be6751f3394","latitude":"23.79565310","longitude":"86.43038590","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-10-27T04:35:32.846Z
created_time: 2023-10-27T04:35:32.846Z
type_: 13