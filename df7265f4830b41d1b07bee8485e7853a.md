id: df7265f4830b41d1b07bee8485e7853a
parent_id: 
item_type: 1
item_id: 0dc82446b90748a394a37276fd8e73b2
item_updated_time: 1707183058861
title_diff: "[{\"diffs\":[[1,\"Traits: Interfacing with Code\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":29}]"
body_diff: "[{\"diffs\":[[1,\"## Traits:\\\n- Traits encapsulates (combines) a group of function to make the behaviour (functions) of struct abstract.\\\n- It allows to create shared behaviour between different structs.\\\n- It tells a rust compiler about functionality that a type must provide.\\\n- When comparing to other languages, Traits in Rust can be thought of as somewhat similar to an interface.\\\n\\t- It allows to encapsulate functions with or without a a function body.\\\n\\t\\t- A function with body is also know as default function\\\n\\t\\t- In rust, a default function can only access other trait functions \\\n\\t\\t- Struct fileds cannot be accessed by trait function (eg: the field `a` of SumInt cannot be access like `&self.a` in the trait function)\\\n\\t\\t- It can be accessed into the fuction that is implemented by struct.\\\n\\t- The implementor type must implement the function without the body   (i.e, only has a function signature no body)\\\n\\t- And it can ignore the methods already defined in Trait (Also called Default Implementation).\\\n\\t- A Default implementation can call other function inside the trait defination.\\\n- A trait mainly has two type of statements inside them:\\\n\\t-  `function`: A function signature, or a function with default implementation\\\n\\t-  `associated type`: It is a type that implementor needs to speficy, making traits to be used without `generics`\\\n- Using traits in function:\\\n\\t1. `impl trait` : A signal for the compiler to infer actaul type under the hood.\\\n\\t2. `Trait Object`\\\n\\t3.  Generics by using type constraints.\\\n\\\n\\\n### Defining Trait:\\\n- A trait is defined similar to `impl` block but with `trait` keyword inplace of `impl`\\\n- In `trait` we generally do not define a body and only a type signature\\\n-  After defining, it is implement it with `impl TraitName for ItemName` block\\\n- Example\\\n\\t ```rust\\\n\\\n\\t\\tpub trait Calc {\\\n\\\n\\t\\t\\ttype Associate : std::fmt::Display;\\\n\\\n\\t\\t\\tpub fn sum(&self) -> Associate;\\\n\\t\\t\\tpub fn sub(&self) -> Associate;\\\n\\\n\\t\\t\\tfn show(&self) -> Self::Associate {\\\n\\t\\t\\t\\tself.add() // trait function are accessible\\\n\\\n\\t\\t\\t\\t// let a be field in some struct SumInt, it is not accesible\\\n\\t\\t\\t\\t// into the trait function\\\n\\t\\t\\t\\t//println!(\\\"a is {}\\\", &self.a)\\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\t ```\\\n \\\n \\\n### Implementing trait using struct\\\n- it is implement it with syntax:\\\n\\t-\\t `impl TraitName for TypeName` block\\\n- Example:\\\n\\t ```rust\\\n\\\n\\t\\tstruct SumInt {\\\n\\t\\t\\ta: u64,\\\n\\t\\t\\tb: u64\\\n\\t\\t}\\\n\\\n\\t\\tstruct SumFloat {\\\n\\t\\t\\ta: f64,\\\n\\t\\t\\tb: f64\\\n\\t\\t}\\\n\\\n\\\n\\t\\t// Calc trait implemented by struct SumInt\\\n\\t\\timpl Calc for SumInt {\\\n\\t\\t\\tfn add(&self) -> u64 {\\\n\\t\\t\\t\\tself.a + self.b\\\n\\t\\t\\t}\\\n\\t\\t\\ttype Associate = u64;\\\n\\t\\t\\tfn sub(&self) -> u64 {\\\n\\t\\t\\t\\tself.a - self.b\\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\\n\\t\\t// Calc trait implemented by struct SumFloat\\\n\\t\\timpl Calc for SumFloat {\\\n\\t\\t\\ttype Associate = f64;\\\n\\\n\\t\\t\\tfn add(&self) -> f64 {\\\n\\t\\t\\t\\tself.a + self.b \\\n\\t\\t\\t}\\\n\\t\\t\\tfn sub(&self) -> f64 {\\\n\\t\\t\\t\\tself.a - self.b \\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\\n\\\n\\t\\t// Using the struct and it's funcions\\\n\\t\\tfn main() {\\\n\\t\\t\\tlet i = SumInt { a: 10, b: 20 };\\\n\\t\\t\\tlet f = SumFloat { a: 10.13, b: 2.23 };\\\n\\\n\\t\\t\\tprintln!(\\\"{}\\\", i.add());\\\n\\t\\t\\tprintln!(\\\"{}\\\", f.add());\\\n\\t\\t}\\\n\\\n\\t```\\\n\\\n### Associated Types:\\\n- Type family: Grouping multiple types together.\\\n- Allow ease of working with traits without using generics.\\\n- Defined inside a triat as syntax:\\\n\\t- type typeName : otherImplementation;\\\n\\t- for example,   type N: std::fmt::Display\\\n- Example:\\\n\\t\\\n\\t```rust\\\n\\\n\\t\\ttrait Graph {\\\n\\t\\t\\ttype N;\\\n\\t\\t\\ttype E;\\\n\\\n\\t\\t\\tfn has_edge(&self, &Self::N, &Self::N) -> bool;\\\n\\t\\t\\tfn edges(&self, &Self::N) -> Vec<Self::E>;\\\n\\t\\t}\\\n\\\n\\\n\\t\\t// These type declarations work the same way as those for functions.\\\n\\t\\t// For example, if we wanted our N type to implement Display, \\\n\\t\\t// so we can print the nodes out, we could do this\\\n\\t\\tuse std::fmt;\\\n\\\n\\t\\ttrait Graph {\\\n\\t\\t\\ttype N: fmt::Display;\\\n\\t\\t\\ttype E;\\\n\\\n\\t\\t\\tfn has_edge(&self, &Self::N, &Self::N) -> bool;\\\n\\t\\t\\tfn edges(&self, &Self::N) -> Vec<Self::E>;\\\n\\t\\t}\\\n\\\n\\t```\\\n\\t\\\n### Implementing Associate Types:\\\n- It is implemented just like any trait with `impl` keyword\\\n- Example:\\\n\\t```rust\\\n\\\n\\t\\tstruct Node;\\\n\\t\\tstruct Edge;\\\n\\t\\tstruct MyGraph;\\\n\\\n\\t\\timpl Graph for MyGraph {\\\n\\t\\t\\ttype N = Node;\\\n\\t\\t\\ttype E = Edge;\\\n\\\n\\t\\t\\tfn has_edge(&self, n1: &Node, n2: &Node) -> bool {\\\n\\t\\t\\t\\ttrue\\\n\\t\\t\\t}\\\n\\\n\\t\\t\\tfn edges(&self, n: &Node) -> Vec<Edge> {\\\n\\t\\t\\t\\tVec::new()\\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\t```\\\n### Creating Trait object with associated types:\\\n- We need to provide a concrete type for the Associate Type when creating a triat object\\\n- Otherwise it will cause error\\\n- Example:\\\n\\t```rust\\t\\\n\\\n\\t\\t// If you try to create a trait object from a trait with an associated type, like this:\\\n\\t\\tlet graph = MyGraph;\\\n\\t\\tlet obj = Box::new(graph) as Box<Graph>;\\\n\\t\\t// It gives error. \\\n\\t\\t// We can’t create a trait object like this, \\\n\\t\\t// because we don’t know the associated types. Instead, we can write this:\\\n\\\n\\t\\t// Correct way:\\\n\\t\\tlet graph = MyGraph;\\\n\\t\\tlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\\\n\\\n\\t\\t// The N=Node syntax allows us to provide a concrete type, Node, for the N type parameter. \\\n\\t\\t// Same with E=Edge. If we didn’t provide this constraint, we couldn’t be sure which\\\n\\t\\t// impl to match this trait object to.\\\n\\\n\\t```\\\n\\t\\t\\\n### Trait as Function Parameter (Trait Bound, Using trait in function)\\\n- Trait can be used as function parameter as traid bounds\\\n- syntax: `&impl TraitName`\\\n- The syntax impllies that given bound represents any struct/enum that implements given trait (here TraitName)\\\n- Example:\\\n\\t```rust\\\n\\t\\t// item: &impl Add -> Trait as function parameter\\\n\\t\\tpub fn notify_sum(item: &impl Add) {\\\n\\t\\tprintln!(\\\"Sum is {}\\\"#, item.show());\\\n\\t\\t}\\\n\\\n\\\n\\t\\tfn main() {\\\n\\t\\t\\tlet i = SumInt { a: 10, b: 20 };\\\n\\t\\t\\tlet f = SumFloat { a: 10.13, b: 2.23 };\\\n\\t\\t\\tnotify_sum(&i);\\\n\\t\\t\\tnotify_sum(&f);\\\n\\t\\t}\\\n\\\n\\t```\\\n\\\n### Trait as Function Rerturn\\\n- Similar to trait bounds, an impl Trait syntax can be used in function arguments and return values.\\\n- For a return type, `impl Trait` means that the return type is some concrete type that implements the trait, without naming the type. \\\n- This can be useful when you don’t want to expose the concrete type in a public API.\\\n- Example: `fh pair_of()`\\\n\\t```rust\\\n\\t\\t// Syntactic sugar for:\\\n\\t\\t// fn add_42_millions<T: Into<i32>>(x: T) -> i32 {\\\n\\t\\tfn add_42_millions(x: impl Into<i32>) -> i32 {\\\n\\t\\t\\tx.into() + 42_000_000\\\n\\t\\t}\\\n\\\n\\t\\tfn pair_of(x: u32) -> impl std::fmt::Debug {\\\n\\t\\t\\t(x + 1, x - 1)\\\n\\t\\t}\\\n\\\n\\t\\tfn main() {\\\n\\t\\t\\tlet many = add_42_millions(42_i8);\\\n\\t\\t\\tprintln!(\\\"{many}\\\");\\\n\\t\\t\\tlet many_more = add_42_millions(10_000_000);\\\n\\t\\t\\tprintln!(\\\"{many_more}\\\");\\\n\\t\\t\\tlet debuggable = pair_of(27);\\\n\\t\\t\\tprintln!(\\\"debuggable: {debuggable:?}\\\");\\\n\\t\\t}\\\n\\\n\\t```\\\n\\\n### Multiple Trait Bounds (Using trait in function)\\\n- A generic type parameter can have more than one trait bound\\\n- `+` operator is used to bound more than one trait.\\\n- Example:\\\n\\t```rust\\\n\\t\\t// Generic Type Parameter with one bound \\\n\\t\\tfn foo<T: Clone>(x: T) {\\\n\\t\\t\\tx.clone();\\\n\\t\\t}\\\n\\\n\\\n\\t\\tuse std::fmt::Debug;\\\n\\t\\t// Generic Type Parameter with two bound `Clone` and `Debug` \\\n\\t\\tfn foo<T: Clone + Debug>(x: T) {\\\n\\t\\t\\tx.clone();\\\n\\t\\t\\tprintln!(\\\"{:?}\\\", x);\\\n\\t\\t}\\\n\\t```\\\n\\\n### Where Caluse\\\n\\\n- `where` clause is used when we need a large number of Trait bound with multiple generic type\\\n-  It is used to make the function syntax more readable\\\n-  Example:\\\n\\t```rust\\\n\\t\\t// Function definition without where clause\\\n\\t\\tfn foo<T: Clone, K: Clone + Debug, L: Debug>(x: T, y: K, z: L) {\\\n\\t\\t\\tx.clone();\\\n\\t\\t\\ty.clone();\\\n\\t\\t\\tprintln!(\\\"{:?}\\\", z);\\\n\\t\\t}\\\n\\\n\\t\\t// Same Function, with a a where clause\\\n\\t\\t\\tfn foo<T, K, L>(x: T, y: K, z: L)\\\n\\t\\t\\twhere T: Clone,\\\n\\t\\t\\t\\t  K: Clone + Debug\\\n\\t\\t\\t\\t  L: Debug {\\\n\\\n\\t\\t\\tx.clone();\\\n\\t\\t\\ty.clone();\\\n\\t\\t\\tprintln!(\\\"{:?}\\\", z);\\\n\\t\\t}\\\n\\\n\\t```\\\n\\\n### Trait Inheritance\\\n- A train can inherit other trait using\\t`:` notation\\\n- Implementor of a trait also needs to implement the inherited traits.\\\n- Implenentor implements all trait with individual `impl TraitName for Type` block\\\n- Example:\\\n\\t```rust\\\n\\\n\\t\\ttrait Foo {\\\n\\t\\t\\tfn foo(&self);\\\n\\t\\t}\\\n\\\n\\t\\t// FooBar inheritaing Foo trait\\\n\\t\\ttrait FooBar : Foo {\\\n\\t\\t\\tfn foobar(&self);\\\n\\t\\t}\\\n\\\n\\\n\\\n\\t\\t// Implementors of FooBar must also implement Foo, like this:\\\n\\\n\\t\\tstruct Baz;\\\n\\\n\\t\\timpl Foo for Baz {\\\n\\t\\t\\tfn foo(&self) { println!(\\\"foo\\\"); }\\\n\\t\\t}\\\n\\\n\\t\\timpl FooBar for Baz {\\\n\\t\\t\\tfn foobar(&self) { println!(\\\"foobar\\\"); }\\\n\\t\\t}\\\n\\\n\\t```\\\n\\\n### Deriving Traits\\\n- Rust provides an attribute called `Derive`\\\n- This attribute allows to let Rust automatically implement traits for us.\\\n- However deriving is limited to a set of built-in traits. These are:\\\n\\t- Clone\\\n    - Copy\\\n    - Debug\\\n    - Default\\\n    - Eq\\\n    - Hash\\\n    - Ord\\\n    - PartialEq\\\n    - PartialOrd\\\n- Extranal module may also provide traits to be derives, \\\n\\t- For example: `serde-rs` provides `Serialiaze` or `Deserialize`\\\n- Example:\\\n\\t```rust\\\n\\\n\\t\\t#[derive(Debug)]    // <- using derive attribute to let Rust implement `Debug` Trait\\\n\\t\\tstruct Foo;\\\n\\\n\\t\\tfn main() {\\\n\\t\\t\\tprintln!(\\\"{:?}\\\", Foo);\\\n\\t\\t}\\\n\\\n\\t```\\\n\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":8606}]"
metadata_diff: {"new":{"id":"0dc82446b90748a394a37276fd8e73b2","parent_id":"6260d9c9d06f4a5bb6de5be6751f3394","latitude":"26.44656980","longitude":"85.90745260","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":1665731851354,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_data":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-02-06T01:31:04.028Z
created_time: 2024-02-06T01:31:04.028Z
type_: 13