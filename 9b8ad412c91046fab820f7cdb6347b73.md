id: 9b8ad412c91046fab820f7cdb6347b73
parent_id: 690ca3874c2444ba95a11c3a89068872
item_type: 1
item_id: 81f7a13041e84edd8fa766bbb2ea13f0
item_updated_time: 1707181235409
title_diff: "[]"
body_diff: "[{\"diffs\":[[0,\"##\"],[-1,\"#\"],[0,\" Generic\"]],\"start1\":0,\"start2\":0,\"length1\":11,\"length2\":10},{\"diffs\":[[0,\"can \"],[-1,\"operate on different data types without sacrificing type safety or performance\"],[1,\"work for multiple types of arguments. \\\n-  These are called `papametric polymorphism`, which mean that  Type or functions can have multiple form over a given parameter.\\\n-  For example, we might write a function to find the largest item in a list that works for any type of item by making the function generic over the type of items in the list. \\\n-  \\\n```rust\\\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\\\n    let mut largest = &list[0];\\\n    for item in list {\\\n        if item > largest {\\\n            largest = item;\\\n        }\\\n    }\\\n    largest\\\n}\\\n\\\nfn main() {\\\n    let numbers = vec![34, 50, 25, 100, 65];\\\n    let result = largest(&numbers);\\\n    println!(\\\"The largest number is {}\\\", result);\\\n    \\\n    let chars = vec!['a', 'b', 'c', 'z'];\\\n    let result = largest(&chars);\\\n    println!(\\\"The largest char is {}\\\", result);\\\n}\\\n\\\n```\\\n- In this example, the largest function is generic over the type T as long as T implements the PartialOrd trait, which allows for comparison. This enables the function to work with both numeric types and characters.\\\n\\\n### Rust Standard Library Generics\\\n- `enum Option<T>`\\\n- `enum Result<T, E>`\\\n\\\n\\\n\\\n### Generic Data Types\\\n- Generics be used define structures, enums can operate on any type.\\\n```rust\\\n// Defining a Generic Type\\\n#[derive(Debug)]\\\nstruct Point<T> {\\\n\\tx: T,\\\n\\ty: T\\\n}\\\n\\\n\\\n// Generic Implementation for a Generic type\\\nimpl<T> Point<T> {\\\n\\tfn coords(&self) -> (&T, &T) {\\\n\\t\\t(&self.x, &self.y)\\\n\\t}\\\n}\\\n\\\n\\\nfn main(){\\\n\\tlet integer = Point{x:1, y:2};\\\n\\tlet float = Point{x:1.1, y:2.2};\\\n\\t\\\n\\tprintln!(\\\"{integer:?} and {float:?}\\\");\\\n\\tprintln!(\\\"{coords: {:?}\\\", integer.coords());\\\n}\\\n\\\n```\\\n- In the example above `impl<T> Point<T> {}`, `impl<T>` and `Point<T>` are seperate section for generic type T.\\\n- `impl<T>` Makes the method `coords` generic, where as Point<T> makes the struct generic.\\\n- It is possible to write `impl Point<u32> { .. }`.\\\n\\t- Point is still generic and you can use `Point<f64>`, but methods in this block will only be available for `Point<u32>` as the `impl` is not generic anymore.\\\n \\\n\\\n### Generic Functions\\\n- We can write functions that take generic type with similar syntax\\\n\\\n```rust\\\nfn takes_anything<T>(x: T){\\\n\\t\\\n\\t}\\\n```\"]],\"start1\":50,\"start2\":50,\"length1\":82,\"length2\":2152}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-02-06T01:01:03.788Z
created_time: 2024-02-06T01:01:03.788Z
type_: 13