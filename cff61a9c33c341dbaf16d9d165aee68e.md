id: cff61a9c33c341dbaf16d9d165aee68e
parent_id: a795a2acf9f74bd4a7368e20c04fed55
item_type: 1
item_id: 3622300e1e5142e0844722fb308da49a
item_updated_time: 1698512316819
title_diff: "[]"
body_diff: "[{\"diffs\":[[0,\"### \"],[-1,\"Conftest.py\\\n- \"],[1,\"conftest.py\\\n- conftest.py is used to fixtures, hooks, and other configurations\\\n- These are then are shared across multiple test files within a pytest test suite. \\\n\\\n\\\n### Fixtures, Hooks, Configurations\\\n- **Fixtures**: Fixtures are functions that provide a set of preconditions necessary for running tests. For example, you might create a fixture that sets up a database connection or prepares some data for your tests. Fixtures defined in conftest.py can be used in multiple test files without duplicating code.\\\n\\\n- **Hooks**: Hooks are special functions in pytest that allow you to customize and extend the testing process. These hooks can be defined in conftest.py to influence how pytest runs your tests.\\\n\\\n- **Configurations**: You can use conftest.py to set various configuration options for your tests, such as command-line options, plugin configuration, and more.\\\n \\\n \\\n ```python\\\nimport pytest\\\n\\\n# Define a fixture\\\n@pytest.fixture\\\ndef database_connection():\\\n    # Code to set up a database connection\\\n    connection = connect_to_database()\\\n    yield connection\\\n    # Code to tear down the database connection\\\n\\\n# Configuration options\\\ndef pytest_addoption(parser):\\\n    parser.addoption(\\\"--runslow\\\", action=\\\"store_true\\\", help=\\\"Run slow tests\\\")\\\n\\\n# Hook to skip slow tests if not requested\\\ndef pytest_collection_modifyitems(config, items):\\\n    if not config.getoption(\\\"--runslow\\\"):\\\n        skip_slow = pytest.mark.skip(reason=\\\"Need --runslow option to run this test\\\")\\\n        for item in items:\\\n            if \\\"slow\\\" in item.keywords:\\\n                item.add_marker(skip_slow)\\\n\\\n```\\\n\\\n### A simple example of Hook\\\n```python\\\n# conftest.py\\\n\\\nimport pytest\\\n\\\n# Define a custom hook that modifies test items\\\ndef pytest_collection_modifyitems(config, items):\\\n    for item in items:\\\n        # Add a custom marker to all test items\\\n        item.add_marker(pytest.mark.custom_marker)\\\n\\\n# Define a simple test function that uses the custom marker\\\n@pytest.mark.custom_marker\\\ndef test_example():\\\n    assert 1 + 1 == 2\\\n```\\\n\\\nIn this example:\\\n\\\n- We define a custom hook, `pytest_collection_modifyitems`, in the conftest.py file. This hook is called when pytest is collecting test items before the tests are run.\\\n- Inside the hook, we iterate through all the test items (test functions, in this case) in the items list.\\\n- We add a custom marker, `pytest.mark.custom_marker,` to each test item using the `add_marker` method. Markers are used to categorize and filter tests, and you can create your own custom markers to provide metadata or special behavior to your tests.\\\n- In the `test_example` function, we apply the custom marker we defined earlier to the test. This is just an example to show how the custom marker can be used.\\\n\\\nWhen tests are run, pytest will automatically call the `pytest_collection_modifyitems` hook, and all the test functions (in this case, just test_example) will have the `custom_marker` applied to them. You can use this marker to filter or customize the behavior of specific tests, or to provide additional information about the tests.\\\n\"]],\"start1\":2330,\"start2\":2330,\"length1\":18,\"length2\":3049}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-10-28T17:07:06.860Z
created_time: 2023-10-28T17:07:06.860Z
type_: 13