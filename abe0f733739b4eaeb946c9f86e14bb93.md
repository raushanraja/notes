id: abe0f733739b4eaeb946c9f86e14bb93
parent_id: 1d0e5f1224fc4eca81b19cf38dafab71
item_type: 1
item_id: 6eb9098ded6e47ba92c4944d8239c20b
item_updated_time: 1683749479887
title_diff: "[]"
body_diff: "[{\"diffs\":[[0,\"### \"],[-1,\"Match\\\n\"],[1,\"match\\\n- Rust provides pattern matching via the match keyword\\\n-  Whicn can compare a value to a series of patterns and execute code based on the matching pattern.\\\n- It ensures all possible cases are handled by checking if the value fits a pattern.\\\n- Match arms have a pattern and code that's executed if the value fits the pattern.\\\n- The resulting value of the expression in the matching arm is returned for the entire match.\\\n- Curly brackets aren't needed for short code blocks.\\\n- It can be used like a C switch. \\\n- Important Syntax consideration:\\\n\\t- \\tThe first matching arm is evaluated and no further evaluation done there.\\\n\\t- \\t all possible values must be covered.\\\n- Types of match usages:\\\n\\t- Destructuring\\\n\\t- Guards\\\n\\t- Binding\\\n\\\n#### Destructuring:\\\n- A match block can destructure items in a variety of ways.\\\n    - Destructuring Tuples\\\n    - Destructuring Arrays and Slices\\\n    - Destructuring Enums\\\n    - Destructuring Pointers\\\n    - Destructuring Structures\\\n\\t\\\n##### Destructuring Tuples:\\\n\\\n ```rust\\\nfn main() {\\\n\\tlet triple = (0, -2, 3);\\\n\\t// TODO ^ Try different values for `triple`\\\n\\\n\\tprintln!(\\\"Tell me about {:?}\\\", triple);\\\n\\t// Match can be used to destructure a tuple\\\n\\tmatch triple {\\\n\\t\\t// Destructure the second and third elements\\\n\\t\\t(0, y, z) => println!(\\\"First is `0`, `y` is {:?}, and `z` is {:?}\\\", y, z),\\\n\\t\\t(1, ..)  => println!(\\\"First is `1` and the rest doesn't matter\\\"),\\\n\\t\\t(.., 2)  => println!(\\\"last is `2` and the rest doesn't matter\\\"),\\\n\\t\\t(3, .., 4)  => println!(\\\"First is `3`, last is `4`, and the rest doesn't matter\\\"),\\\n\\t\\t// `..` can be used to ignore the rest of the tuple\\\n\\t\\t_      => println!(\\\"It doesn't matter what they are\\\"),\\\n\\t\\t// `_` means don't bind the value to a variable\\\n\\t}\\\n}\\\n```\\\n##### Destructuring Arrays and Slices\\\n```rust\\\nfn main() {\\\n    // Try changing the values in the array, or make it a slice!\\\n    let array = [1, -2, 6];\\\n\\\n    match array {\\\n        // Binds the second and the third elements to the respective variables\\\n        [0, second, third] =>\\\n            println!(\\\"array[0] = 0, array[1] = {}, array[2] = {}\\\", second, third),\\\n\\\n        // Single values can be ignored with _\\\n        [1, _, third] => println!(\\\n            \\\"array[0] = 1, array[2] = {} and array[1] was ignored\\\",\\\n            third\\\n        ),\\\n\\\n        // You can also bind some and ignore the rest\\\n        [-1, second, ..] => println!(\\\n            \\\"array[0] = -1, array[1] = {} and all the other ones were ignored\\\",\\\n            second\\\n        ),\\\n        // The code below would not compile\\\n        // [-1, second] => ...\\\n\\\n        // Or store them in another array/slice (the type depends on\\\n        // that of the value that is being matched against)\\\n        [3, second, tail @ ..] => println!(\\\n            \\\"array[0] = 3, array[1] = {} and the other elements were {:?}\\\",\\\n            second, tail\\\n        ),\\\n\\\n        // Combining these patterns, we can, for example, bind the first and\\\n        // last values, and store the rest of them in a single array\\\n        [first, middle @ .., last] => println!(\\\n            \\\"array[0] = {}, middle = {:?}, array[2] = {}\\\",\\\n            first, middle, last\\\n        ),\\\n    }\\\n}\\\n```\\\n### if-let\\\n### let-else\\\n### while-let\"]],\"start1\":1074,\"start2\":1074,\"length1\":10,\"length2\":3159}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-05-10T20:11:23.943Z
created_time: 2023-05-10T20:11:23.943Z
type_: 13