id: 919bb99dc9b44cd082c1cc218f2dc481
parent_id: 
item_type: 1
item_id: 63b28440f5424f398fa1343d2ed693a1
item_updated_time: 1683746251495
title_diff: "[{\"diffs\":[[1,\"Organization: Function, Struct, Module\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":38}]"
body_diff: "[{\"diffs\":[[1,\"## Organizing for Reuse:\\\n- Encapsulating`behaviour` with `function`\\\n- Encapsulation `data` with `struct`\\\n- Exporting and Importig `moudles`\\\n* * *\\\n\\\n## Function:\\\n-  Function encapsulates behaviour\\\n-  It is code construct that call be called from different places\\\n-  It takes parameter and retruns value to transfer data back and forth.\\\n-  In Rust, functions are associated with struct\\\n-  A type may have two types of function:\\\n\\t-  `Associated function`: Function associated with Type instead to a particular instance\\\n\\t\\t-  `::` syntax is used to access the function.\\\n\\t-  `Method` Functions associated with a particular instance of a type.\\\n\\t\\t-  `.` (dot) is used to access the function\\\n- Syntax:\\\n\\t```rust\\\n\\\n\\t\\tfn functon_name() -> return_type {\\\n\\t\\t\\t// function body\\\n\\t\\t}\\\n\\\n\\t\\t//Example:\\\n\\t\\tfn four() -> i32 {\\\n\\t\\t\\t4\\\n\\t\\t}\\\n\\t\\t\\\n\\t```\\\n- Parameterizing Functoins:\\\n\\t- Parameters are variables that are available when function executes\\\n\\t- There variable value are filled with values from the outside.\\\n\\t- Few parameter types:\\\n\\\n\\t| Parameter Type  | Explaination  | \\\n\\t|---|---|\\\n\\t|`fn f(a: &str)` | `&`- prefix provides an immutable reference to a function. (Borrow).\\\n\\t|`fn f(mut a: String)`| `mut` provides a varialbe that is mutable (Borrow).\\\n\\t|`no prefix`| Simple transfer of ownership into the function. eg: `fn(a:i32)`\\\n\\t|`impl`     | Prefix Allows structs/enums that implement a trait dynamically. eg: `fn(a: impl str::io::Write)`|\\\n\\t|T `generic types`| T or other `generic types` are represented through letters. eg: `fn f<T>(a: T)` |\\\n\\\n* * *\\\n## Struct\\\n- `struct` enacpsulates the data.\\\n- It is use to store complex type under a single variable to ensure unformity and reusablity.\\\n- When allocating a struct, the values for the members are required to be provided.\\\n- Syntax:\\\n\\t```rust\\\n\\\n\\t\\tstruct StructName { \\t\\t\\t\\t// convention: struct name is CamelCase\\\n\\t\\t\\tvariable_one: type,\\\n\\t\\t\\tvariable_two: type\\\n\\t\\t}\\\n\\\n\\t\\t// Example:\\\n\\t\\t// Defining a struct\\\n\\t\\tstruct Door {\\\n\\t\\t\\twidth: u32,\\\n\\t\\t\\theight: u32,\\\n\\t\\t\\tis_open: bool\\\n\\t\\t}\\\n\\\n\\t\\t// Using the struct\\\n\\t\\tfn main(){\\\n\\t\\t\\tlet living_room_door = Door({width:100, height:200, is_open: false});\\t\\\n\\t\\t\\tprintln!(\\\"Is room open {}\\\", living_room_door.is_open);\\\n\\t\\t}\\\n\\t\\t\\\n\\t```\\\n- Modifier with struct:\\\n\\t- modifiers with structs are use to restrict the access to struct and its members\\\n\\t- Typically `pub` is the modifier used in Rust.\\\n\\t- Example:\\\n\\t\\t```rust\\\n\\\n\\t\\t\\tpub struct Door{ \\t\\t\\t\\t// Makes struct accessible from outside\\\n\\t\\t\\t\\twidth: u32,\\t\\t\\t\\t\\t// ❌ Not accessible from different module\\\n\\t\\t\\t\\theight: u32,\\t\\t\\t\\t// ❌ Not accessible from different module\\\n\\t\\t\\t\\tpub is_bool: bool \\t\\t\\t\\t// ✔️ Accessible from different module\\\n\\t\\t\\t}\\\n\\t\\t\\t\\\n\\t\\t```\\\n- Association `function` with `struct`\\\n\\t- `impl` block provides function implementation for a specified struct (or even for enums).\\\n\\t- A `impl` block can have multiple function.\\\n\\t- It is also fine to have several `impl` blocks too.\\\n\\t- `impl` is defined with the same name as struct.\\\n\\t- Two types of functions in `impl` block:\\\n\\t\\t- General function that are bound to Struct and do not have instance data available to it.\\\n\\t\\t\\t- Accessed by `::` operator\\\n\\t\\t- Instance bound function that have the instance data and can mutate the data.\\\n\\t\\t\\t- Accessed by `.` operator\\\n\\t- Example:\\\n\\t\\t```rust\\\n\\\n\\t\\t\\t// Defining a struct\\t\\\n\\t\\t\\tstruct Door {\\\n\\t\\t\\t\\twidth: u32,\\\n\\t\\t\\t\\theight: u32,\\\n\\t\\t\\t\\tis_open: bool\\\n\\t\\t\\t}\\\n\\\n\\t\\t\\t// Associating functions with a struct\\\n\\t\\t\\t// impl has same name as struct\\\n\\t\\t\\timpl Door {\\\n\\t\\t\\t\\t\\\n\\t\\t\\t\\t// General method\\\n\\t\\t\\t\\t// Don't have insatnce data availble to this method\\\n\\t\\t\\t\\t// And return type is Self, which refers to current type\\\n\\t\\t\\t\\tpub fn new(width: u32, height: u32, is_open: bool) -> Self {\\\n\\t\\t\\t\\t\\tDoor{\\t\\t\\t\\t\\t\\t     \\\n\\t\\t\\t\\t\\t\\twidth,   // shorthand for width:width\\\n\\t\\t\\t\\t\\t\\theight,\\\n\\t\\t\\t\\t\\t\\tis_book\\\n\\t\\t\\t\\t\\t}\\\n\\t\\t\\t\\t}\\t\\\n\\t\\t\\t\\t\\\n\\t\\t\\t\\t// Instance bound method\\\n\\t\\t\\t\\t// first parameter is self and it can be mutable if defined with &mut \\\n\\t\\t\\t\\tpub fn open(&mut self) {\\\n\\t\\t\\t\\t\\tself.is_open = true;\\\n\\t\\t\\t\\t} \\\n\\t\\t\\t\\t\\\n\\t\\t\\t\\tpub fn close(&mut self){\\\n\\t\\t\\t\\t\\tself.is_open = false;\\\n\\t\\t\\t\\t}\\\n\\t\\t\\t}\\\n\\t\\t\\t\\\n\\t\\t```\\\n\\t\\t\\\n## Modules: Export and Import\\\n- Module is used to abstract code component for easy reuse.\\\n- These modules can be used from anywhere by importting it.\\\n- Basic Steps:\\\n\\t- Create a functoin/struct/enum etc that needs to be converted into a module\\\n\\t- Use `mod` keyword to declare it as a module\\\n\\t- Use `use` keyword to get a specific thing or whole module into other file.\\\n- Aliasing types and modules\\\n\\t- using ` as ;` contruct : `use Door as Gate;`\\\n\\t- using `type` keyword : `type TwoNumbers = (u64, u64);`\\\n\\t- using `pub type` keyword: `pub type EmptyResult = Result<(), MyError>;*emphasized text*` \\\n- Different ways of creating a module:\\\n\\\n1. Creating modules in same file using `mod` keyword\\\n\\t- `mod` keyword isused with a module name, in the same file\\\n\\t- `pub` keyword is used with fucntion/enun/struct which is to be exported\\\n\\t- Example:\\\n\\t\\t```rust\\\n\\\n\\t\\t\\t// Example of creating a module\\\n\\t\\t\\t// Both module and function that is using the module are in same file.\\\n\\\n\\t\\t\\tmod PhysicalAccessControl {\\t\\t// Creating a module\\\n\\t\\t\\t\\tpub struct Door {\\\n\\t\\t\\t\\t\\tpub width: u32,\\\n\\t\\t\\t\\t\\tpub heigh: u32,\\\n\\t\\t\\t\\t\\tpub is_open: bool\\\n\\t\\t\\t\\t}\\\n\\t\\t\\t\\t\\\n\\t\\t\\t\\timpl Door{\\\n\\t\\t\\t\\t\\tpub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n\\t\\t\\t\\t\\t\\tDoor{\\\n\\t\\t\\t\\t\\t\\t\\twidth,\\\n\\t\\t\\t\\t\\t\\t\\theight,\\\n\\t\\t\\t\\t\\t\\t\\tis_open,\\\n\\t\\t\\t\\t\\t\\t}\\\n\\t\\t\\t\\t\\t}\\\n\\t\\t\\t\\t}\\\n\\t\\t\\t}\\t\\\n\\\n\\t\\\n\\t\\t\\t// Using PhysicalAccessControl module create above in different scope\\\n\\t\\t\\tfn main(){\\t\\t\\t\\\n\\t\\t\\t\\tlet my_door = PhysicalAccessControl::Door::new(100, 200, false);\\\n\\t\\t\\t}\\\n\\t\\t\\t\\\n\\t\\t```\\\n2. Creating module in a dedicated file\\\n\\t- Create a dedicated file with required code.\\\n\\t- The filename is used as module name, the module name is not defined in the module code.\\\n\\t- The file which usages it need to declare the module in a `mod` statement with filename.\\\n\\t- Afterward, a `use` statement enables the inclusion of module's code in current file.\\\n\\t- Example:\\\n\\t```rust\\\n\\\n\\t   // PhysicalAccessControl.rs   <---- A dedicated file for the module \\t\\t\\t\\t\\\n\\t\\tpub struct Door {  \\t    //   <---- We are not using `mod` statement with module name here\\\n\\t\\t\\tpub width: u32,\\\n\\t\\t\\tpub heigh: u32,\\\n\\t\\t\\tpub is_open: bool\\\n\\t\\t}\\\n\\\n\\t\\timpl Door{\\\n\\t\\t\\tpub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n\\t\\t\\t\\tDoor {\\\n\\t\\t\\t\\t\\twidth,\\\n\\t\\t\\t\\t\\theight,\\\n\\t\\t\\t\\t\\tis_open,\\\n\\t\\t\\t\\t}\\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\\n\\t\\t// main.rs       \\t\\t       \\t   <----Different file which usages the module\\\n\\t\\tmod PhysicalAccessControl;  //         <---- using `mod` statement to declare the module\\\n\\t\\tuse PhysicalAccessControl::Door; //    <---- using `use` statmenet to include `Door` struct\\\n\\\n\\t\\tfn main(){\\\n\\t\\t\\tlet my_door = Door::new(100, 300, false);\\t\\\n\\t\\t}\\\n\\t\\t\\t\\\n\\t```\\\n3. Modules when they are in different directories (Sub-modules)\\\n\\t- When modules are further divided into multiple parts and different directories.\\\n\\t- Each directory needs to contain a file called `mod.rs` to create it a submodule.\\\n\\t- Each new file has to be declared in `mod.rs` with `mod submodule;` keyword for `submodule.rs` file.\\\n\\t- `use submodule` is used in the file where it is used.\\\n\\t- The root directory contains a `lib.rs` and all top level submodules are declared in lib.rs with mod keyword.\\\n\\t- Example:\\\n\\t```rust\\\n\\\n\\t   // PhysicalAccessControl.rs   <---- A dedicated file for the module \\t\\t\\t\\t\\\n\\t\\tpub struct Door {  \\t    //   <---- We are not using `mod` statement with module name here\\\n\\t\\t\\tpub width: u32,\\\n\\t\\t\\tpub heigh: u32,\\\n\\t\\t\\tpub is_open: bool\\\n\\t\\t}\\\n\\\n\\t\\timpl Door{\\\n\\t\\t\\tpub fn new(width: 32, height: u32, is_open: bool) -> Self {\\\n\\t\\t\\t\\tDoor {\\\n\\t\\t\\t\\t\\twidth,\\\n\\t\\t\\t\\t\\theight,\\\n\\t\\t\\t\\t\\tis_open,\\\n\\t\\t\\t\\t}\\\n\\t\\t\\t}\\\n\\t\\t}\\\n\\\n\\t\\tstruct Window {    //   <---- struct private to moudle, as not using `pub` keyword\\\n\\t\\t\\tpub width: u32,\\\n\\t\\t\\tpub heigh: u32,\\\n\\t\\t\\tpub is_open: bool\\\n\\t\\t}\\\n\\\n\\\n\\\n\\t\\t// main.rs   <----Different file which usages the module defined above\\\n\\t\\tmod PhysicalAccessControl;  //                 \\\n\\t\\tuse PhysicalAccessControl::Door as Gate; //    <---- Aliasing import\\\n\\t\\tuse PhysicalAccessControl::Window; //          <---- Fails because struct is private to module\\\n\\t\\tfn main(){\\\n\\t\\t\\tlet my_door = Gate::new(100, 300, false);\\t\\\n\\t\\t}\\\n\\t\\t\\\n\\t```\\\n\\\n### Enum\\\n- User defined data types with definite values\\\n- Syntax:\\\n```rust\\\n\\tenum name\\\n\\t{\\\n\\t\\tvariable1,\\\n\\t\\tvariable2,\\\n\\t\\tvariable3,\\\n\\t}\\\n\\\n```\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":8044}]"
metadata_diff: {"new":{"id":"63b28440f5424f398fa1343d2ed693a1","parent_id":"6260d9c9d06f4a5bb6de5be6751f3394","latitude":"19.07598370","longitude":"72.87765590","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":1674738582925,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-05-10T19:21:23.710Z
created_time: 2023-05-10T19:21:23.710Z
type_: 13