id: 58871a1f58764079a4a48990e883462b
parent_id: 
item_type: 1
item_id: c0f5889066634048bdbdd371a9336432
item_updated_time: 1705262446145
title_diff: "[{\"diffs\":[[1,\"Python Bytes\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":12}]"
body_diff: "[{\"diffs\":[[1,\"# Python Bytes Object\\\n- Immutable sequence of single byte.\\\n- bytearray is similar to bytes, with one difference that bytearray is mutable\\\n- Since 2 hexadecimal digits correspond precisely to a single byte, \\\nhexadecimal numbers are a commonly used format for describing binary data.\\\n- That's why when you create a byte, the hexadecimal format prints out to console\\\n\\\n- Ways to create a byte:\\\n    - use method `bytes([source [,encoding[, errors]]])`\\\n    - use method `bytes.fromhex('somehexnumber like: 2E')`\\\n        - In this, the string must contain two hexadecimal digits but byte\\\n        - like 0E , where as passing just 'E' won't work\\\n    - using `b` like b'hello'\\\n\\\n\\\n- Convert decimal to hex\\\n    - hex(5)\\\n- Convert hex to decimal\\\n    - int('0x05', 16)\\\n- Hex to bytes array\\\n    - bytes.fromhex('0x05'[2:])\\\n- Convert bytes to hext \\\n    - b'\\\\xf0\\\\xf1\\\\xf2'.hex()\\\n\\\n\\\n## struct\\\n- Python does provides a module called `struct` that can help in creating binary data for transmittin over network\\\n- It helps in creating a byte with given represntation\\\n- Like let's say we want 12 (a deciaml) value to be represented by a 16 bit\\\nwe can do something like struct.pack('>H', 12)\\\n- The module provides easy way to define data when packing and unpacking using \\\n    - Byte order, Size , Alignemnt Character, which is an optional prefix to other format Character\\\n    - Format Character , these are not optional \\\n\\\n- Main Methods:\\\n    - struct.pack(format, v1, v2, ...)\\\n\\t- struct.pack_into(format, buffer, offset, v1, v2, ...)\\\n\\t- struct.unpack(format, buffer)\\\n\\t- struct.unpack_from(format, /, buffer, offset=0)\\\n\\t- struct.iter_unpack(format, buffer)\\\n\\t- struct.calcsize(format)\\\n\\\n\\\n### Struct Format String\\\n\\\n#### struct Byte Order, Size and Alighemnt\\\n- These are optional prefix\\\n- These are used to define overall properties of the data\\\n\\\n| Character |        Byte order        |    Size   | Alignment |\\\n|-----------|--------------------------|-----------|-----------|\\\n|     @     |           native         |   native  |   native  |\\\n|     =     |           native         |  standard |    none   |\\\n|     <     |      little-endian       |  standard |    none   |\\\n|     >     |        big-endian        |  standard |    none   |\\\n|     !     | network (= big-endian)   |  standard |    none   |\\\n\\\n\\\n### Format Character\\\n- These are not optional\\\n- These describing the actual data and type of padding used\\\n- Therea can be combination of format Character in a format string\\\n- like: `unpack('>bhl', b'\\\\x01\\\\x00\\\\x02\\\\x00\\\\x00\\\\x00\\\\x03')`\\\n- Here, the first chat is byte order char and then all other `bhl` are format Character \\\n\\\n| Format |   C Type          | Python Type     | Standard size | Notes       |\\\n|--------|-------------------|-----------------|---------------|-------------|\\\n| x      | pad byte          | no value        |               | (7)         |\\\n| c      | char              | bytes (length 1)| 1             | (1), (2)    |\\\n| b      | signed char       | integer         | 1             | (1), (2)    |\\\n| B      | unsigned char     | integer         | 1             | (2)         |\\\n| ?      | _Bool             | bool            | 1             | (1)         |\\\n| h      | short             | integer         | 2             | (2)         |\\\n| H      | unsigned short    | integer         | 2             | (2)         |\\\n| i      | int               | integer         | 4             | (2)         |\\\n| I      | unsigned int      | integer         | 4             | (2)         |\\\n| l      | long              | integer         | 4             | (2)         |\\\n| L      | unsigned long     | integer         | 4             | (2)         |\\\n| q      | long long         | integer         | 8             | (2)         |\\\n| Q      | unsigned long long| integer         | 8             | (2)         |\\\n| n      | ssize_t           | integer         |               | (3)         |\\\n| N      | size_t            | integer         |               | (3)         |\\\n| e      | (6)               | float           | 2             | (4)         |\\\n| f      | float             | float           | 4             | (4)         |\\\n| d      | double            | float           | 8             | (4)         |\\\n| s      | char[]            | bytes           |               | (9)         |\\\n| p      | char[]            | bytes           |               | (8)         |\\\n| P      | void*             | integer         |               | (5)         |\\\n\\\n\\\n### There is one more module that might help:\\\n- Codecs \\\n```python\\\nimport codecs\\\n\\\ncodecs.decode('aded', 'hex')\\\n# Output: b'\\\\xad\\\\xed'\\\n\\\ncodecs.encode(b'\\\\xad\\\\xed', 'hex')\\\n# Output: b'aded'\\\n```\\\n\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":4601}]"
metadata_diff: {"new":{"id":"c0f5889066634048bdbdd371a9336432","parent_id":"bf86d6cd320144978f7f426983dc09bd","latitude":"22.80456650","longitude":"86.20287540","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_data":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-01-15T22:58:30.823Z
created_time: 2024-01-15T22:58:30.823Z
type_: 13