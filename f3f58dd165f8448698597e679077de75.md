id: f3f58dd165f8448698597e679077de75
parent_id: abe0f733739b4eaeb946c9f86e14bb93
item_type: 1
item_id: 6eb9098ded6e47ba92c4944d8239c20b
item_updated_time: 1683750683231
title_diff: "[]"
body_diff: "[{\"diffs\":[[0,\"tures\\\n\\t\\\n\"],[1,\"- \"],[0,\"##### De\"]],\"start1\":2035,\"start2\":2035,\"length1\":16,\"length2\":18},{\"diffs\":[[0,\"Tuples:\\\n\"],[-1,\"\"],[0,\"\\\n ```rus\"]],\"start1\":2065,\"start2\":2065,\"length1\":16,\"length2\":16},{\"diffs\":[[0,\"}\\\n}\\\n```\\\n\"],[1,\" - \"],[0,\"##### De\"]],\"start1\":2775,\"start2\":2775,\"length1\":16,\"length2\":19},{\"diffs\":[[0,\" Slices\\\n\"],[-1,\"\"],[0,\"```rust\\\n\"]],\"start1\":2816,\"start2\":2816,\"length1\":16,\"length2\":16},{\"diffs\":[[0,\"e, last\\\n\"],[-1,\"\"],[0,\"        \"]],\"start1\":4170,\"start2\":4170,\"length1\":16,\"length2\":16},{\"diffs\":[[0,\"}\\\n}\\\n```\\\n\"],[1,\"- ##### Destructuring Enums\\\n```rust\\\n// `allow` required to silence warnings because only\\\n// one variant is used.\\\n#[allow(dead_code)]\\\nenum Color {\\\n    // These 3 are specified solely by their name.\\\n    Red,\\\n    Blue,\\\n    Green,\\\n    // These likewise tie `u32` tuples to different names: color models.\\\n    RGB(u32, u32, u32),\\\n    HSV(u32, u32, u32),\\\n    HSL(u32, u32, u32),\\\n    CMY(u32, u32, u32),\\\n    CMYK(u32, u32, u32, u32),\\\n}\\\n\\\nfn main() {\\\n    let color = Color::RGB(122, 17, 40);\\\n    // TODO ^ Try different variants for `color`\\\n\\\n    println!(\\\"What color is it?\\\");\\\n    // An `enum` can be destructured using a `match`.\\\n    match color {\\\n        Color::Red   => println!(\\\"The color is Red!\\\"),\\\n        Color::Blue  => println!(\\\"The color is Blue!\\\"),\\\n        Color::Green => println!(\\\"The color is Green!\\\"),\\\n        Color::RGB(r, g, b) =>\\\n            println!(\\\"Red: {}, green: {}, and blue: {}!\\\", r, g, b),\\\n        Color::HSV(h, s, v) =>\\\n            println!(\\\"Hue: {}, saturation: {}, value: {}!\\\", h, s, v),\\\n        Color::HSL(h, s, l) =>\\\n            println!(\\\"Hue: {}, saturation: {}, lightness: {}!\\\", h, s, l),\\\n        Color::CMY(c, m, y) =>\\\n            println!(\\\"Cyan: {}, magenta: {}, yellow: {}!\\\", c, m, y),\\\n        Color::CMYK(c, m, y, k) =>\\\n            println!(\\\"Cyan: {}, magenta: {}, yellow: {}, key (black): {}!\\\",\\\n                c, m, y, k),\\\n        // Don't need another arm because all variants have been examined\\\n    }\\\n}\\\n```\\\n- ##### Destructuring Pointers\\\n```rust\\\nfn main() {\\\n    // Assign a reference of type `i32`. The `&` signifies there\\\n    // is a reference being assigned.\\\n    let reference = &4;\\\n\\\n    match reference {\\\n        // If `reference` is pattern matched against `&val`, it results\\\n        // in a comparison like:\\\n        // `&i32`\\\n        // `&val`\\\n        // ^ We see that if the matching `&`s are dropped, then the `i32`\\\n        // should be assigned to `val`.\\\n        &val => println!(\\\"Got a value via destructuring: {:?}\\\", val),\\\n    }\\\n\\\n    // To avoid the `&`, you dereference before matching.\\\n    match *reference {\\\n        val => println!(\\\"Got a value via dereferencing: {:?}\\\", val),\\\n    }\\\n\\\n    // What if you don't start with a reference? `reference` was a `&`\\\n    // because the right side was already a reference. This is not\\\n    // a reference because the right side is not one.\\\n    let _not_a_reference = 3;\\\n\\\n    // Rust provides `ref` for exactly this purpose. It modifies the\\\n    // assignment so that a reference is created for the element; this\\\n    // reference is assigned.\\\n    let ref _is_a_reference = 3;\\\n\\\n    // Accordingly, by defining 2 values without references, references\\\n    // can be retrieved via `ref` and `ref mut`.\\\n    let value = 5;\\\n    let mut mut_value = 6;\\\n\\\n    // Use `ref` keyword to create a reference.\\\n    match value {\\\n        ref r => println!(\\\"Got a reference to a value: {:?}\\\", r),\\\n    }\\\n\\\n    // Use `ref mut` similarly.\\\n    match mut_value {\\\n        ref mut m => {\\\n            // Got a reference. Gotta dereference it before we can\\\n            // add anything to it.\\\n            *m += 10;\\\n            println!(\\\"We added 10. `mut_value`: {:?}\\\", m);\\\n        },\\\n    }\\\n}\\\n```\\\n-  ##### Destructuring Structures\\\n```rust\\\nfn main() {\\\n    struct Foo {\\\n        x: (u32, u32),\\\n        y: u32,\\\n    }\\\n\\\n    // Try changing the values in the struct to see what happens\\\n    let foo = Foo { x: (1, 2), y: 3 };\\\n\\\n    match foo {\\\n        Foo { x: (1, b), y } => println!(\\\"First of x is 1, b = {},  y = {} \\\", b, y),\\\n\\\n        // you can destructure structs and rename the variables,\\\n        // the order is not important\\\n        Foo { y: 2, x: i } => println!(\\\"y is 2, i = {:?}\\\", i),\\\n\\\n        // and you can also ignore some variables:\\\n        Foo { y, .. } => println!(\\\"y = {}, we don't care about x\\\", y),\\\n        // this will give an error: pattern does not mention field `x`\\\n        //Foo { y } => println!(\\\"y = {}\\\", y),\\\n    }\\\n}\\\n```\\\n\\\n#### Guards\\\n- In Rust's match expression, guards are additional if conditions added to a match arm pattern.\\\n- These conditions must evaluate to a Boolean value and are separated from the pattern by if.\\\n- The compiler checks that all possible cases are handled in a match expression.\\\n\\t- And it does take gurard condition into consideration for it.\\\n\\t- So all possible cases must be covered, and it includes `_` (default) match anything \\\n\\\n```rust\\\nenum Temperature {\\\n    Celsius(i32),\\\n    Fahrenheit(i32),\\\n}\\\n\\\nfn main() {\\\n    let temperature = Temperature::Celsius(35);\\\n    // ^ TODO try different values for `temperature`\\\n\\\n    match temperature {\\\n        Temperature::Celsius(t) if t > 30 => println!(\\\"{}C is above 30 Celsius\\\", t),\\\n        // The `if condition` part ^ is a guard\\\n        Temperature::Celsius(t) => println!(\\\"{}C is below 30 Celsius\\\", t),\\\n\\\n        Temperature::Fahrenheit(t) if t > 86 => println!(\\\"{}F is above 86 Fahrenheit\\\", t),\\\n        Temperature::Fahrenheit(t) => println!(\\\"{}F is below 86 Fahrenheit\\\", t),\\\n    }\\\n}\\\n\\\n\\\n# Another Example\\\nmatch value {\\\n    1 => println!(\\\"One\\\"),\\\n    2 => println!(\\\"Two\\\"),\\\n    3 => println!(\\\"Three\\\"),\\\n    n if n > 0 && n < 4 => println!(\\\"Value is between 1 and 3\\\"),\\\n    _ => println!(\\\"Something else\\\"),\\\n}\\\n```\\\n\\\n```rust\\\n# Note that the compiler won't take guard conditions \\\ninto account when checking if all patterns are covered\\\nby the match expression.\\\n\\\nfn main() {\\\n    let number: u8 = 4;\\\n\\\n    match number {\\\n        i if i == 0 => println!(\\\"Zero\\\"),\\\n        i if i > 0 => println!(\\\"Greater than zero\\\"),\\\n\\t\\t\\\n\\t\\t\\t\\t // Here we are trying to add guard condition and check \\\n\\t\\t\\t\\t // The value is greater or zero, but we are not covering case where\\\n\\t\\t\\t\\t // the value can be less than zero. So since not all possible cases \\\n\\t\\t\\t\\t // are covered and since compiler does not take gurad cases into \\\n\\t\\t\\t\\t / cosideration while checking if all cases are \\\n        // _ => unreachable!(\\\"Should never happen.\\\"),\\\n        // TODO ^ uncomment to fix compilation\\\n    }\\\n}\\\n```\\\n\"],[0,\"### if-l\"]],\"start1\":4193,\"start2\":4193,\"length1\":16,\"length2\":5900}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-05-10T20:31:23.938Z
created_time: 2023-05-10T20:31:23.938Z
type_: 13